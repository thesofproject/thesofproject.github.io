.. _kernel_user_mode:

Kernel Mode And User Mode
#########################

There are two high level security prospects motivating to implement Kernel-User mode isolation:

1. isolating SoC HW from 3rd party FW code (i.e. loadable FW modules) access,
2. building safe ecosystem for system integrator (e.g. Intel) and 3rd party FW modules integration,
   through loadable FW module address space isolation.

Kernel-User mode isolation mechanism is build on top of DSP MMU, which provides address space
isolation to running FW threads.

.. note::
   Kernel Mode And User Mode specification is heavily depending on MMU support. SOF can operate
   without MMU support. In such case features described in this chapter will not be applicable.

.. _vertical_horizontal_thread_isolation:
.. figure:: images/vertical_horizontal_thread_isolation.svg

   Vertical And Horizontal Thread Isolation Layers

FW code is meant to run at one of privileged levels as shown on
:numref:`vertical_horizontal_thread_isolation`:

* Privileged – running code has access to privileged instructions and other resources (e.g.: SoC HW,
  L2 Local Memory).
* Unprivileged – running code is not permitted to execute privileged instructions, however it can
  directly access its own address mode (code/stack/data) and necessary resources (e.g. shared
  memory). Other operations can be performed through the system call.

The privilege level assignment for loadable modules is left to integrator decision (who builds and
sign SOF). Integrator is capable to instantiate loadable module in privilege or unprivileged level
disregard it's provided as build-in SOF module, integrator module, or 3rd party module.

.. note::
   Zephyr integration note: User Mode module is represented as
   `Zephyr thread <https://docs.zephyrproject.org/3.1.0/kernel/services/threads/index.html>`_

Secure IPC
**********

This sections describes secure IPC handling based on IPC to User Mode module (e.g. 3rd party
module) use case.

Initial IPC handling is done in Kernel interrupt handling routine, which parse IPC message structure
to identify (identify by module id, module instance, DSP core id and security domain) which module
is the target. Further Kernel schedule User Mode module Work Queue thread to finalize IPC message
handling.

.. uml:: images/secure_ipc.pu

Large Config Set IPC handling procedure
=======================================

Assumptions:

 * Secure IPC is handled by
   `Work Queue <https://docs.zephyrproject.org/3.1.0/kernel/services/threads/workqueue.html>`_
   thread (further called Module WQ) to call module IPC callback in isolation to Kernel.

1. Kernel:

   a. Dispatch IPC message to understand which DSP core id and module (identified by module id,
      module instance) is targeted.
   b. Clear Module WQ thread stack to prevent untrusted module read private data left on the stack
      after previous module execution.
   c. Clear IPC shared memory buffer to prevent untrusted module read private data left in the IPC
      shared buffer after previous IPC handling.
   d. Request IPC handling on module:|br|
      If targeting module is running on primary DSP core (core 0) and in Kernel Mode, then call
      "large config set" module callback directly, else proceed to handle IPC using Module WQ:

      1. `Pin <https://docs.zephyrproject.org/3.1.0/kernel/services/threads/index.html#c.k_thread_cpu_mask_enable>`_
         Module WQ thread to the targeted DSP core id.
      2. Map targeting module code and data sections to the Module WQ.
      3. Grant IPC message data read access to the Module WQ using shared memory.
      4. Add IPC handling
         `Work Item <https://docs.zephyrproject.org/3.1.0/kernel/services/threads/workqueue.html#work-item-lifecycle>`_
         to the Module WQ.

2. Module WQ:

   a. Execute job submitted in Work Items, through calling "large config set" callback exposed by
      module callback.

      1. "large config set" callback read IPC message data exposed as shared memory.

   b. Call system call to send IPC reply.
   c. Call system call to remove IPC message data access from the Module WQ.
   d. Call system call to unmap targeted module code and data sections from the Module WQ.

.. note::
   Zephyr integration note: module memory (code and data sections) and IPC data are shared to the
   Module WQ thread through the shared memory. Shared memory shall be implemented using
   `Zephyr Memory Domains <https://docs.zephyrproject.org/3.1.0/kernel/usermode/memory_domain.html#memory-domains>`_.
